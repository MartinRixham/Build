#! /usr/bin/env bash

set -Eeu

RECIPE=recipe.json

DIR=$(dirname $(readlink -f $0))

COMPILER=$(jq -r .compiler $RECIPE)

map()
{
	while read line; do
		$@ $line
	done
}

parmap()
{
	local pids=()

	while read line; do
		$@ $line &
		pids+=($!)
	done

	for pid in ${pids[@]}; do
		wait $pid
	done
}

filter()
{
	while read line; do
		if $@ $line &> /dev/null; then
			echo $line
		fi
	done
}

not()
{
	while read line; do
		if ! $@ $line &> /dev/null; then
			echo $line
		fi
	done
}

verbose()
{
	echo $@
	$@
}

all()
{
	echo $(cat)
}

blank()
{
	echo ''
}

non_empty()
{
	sed '/^$/d'
}

clean()
{
	rm -rf build
}

is_null()
{
	echo $1 | grep -q null
}

get_plugin_and_config()
{
	echo $(echo $@ | jq -r .name) $(echo $@ | jq -c .config)
}

is_validation()
{
	echo $@ | jq .phase | grep -q validate
}

run_plugin()
{
	source $DIR/$1.chevre $2
}

run_plugins()
{
    jq -c .plugins $RECIPE | not is_null | jq -c .[] | filter $1 | map get_plugin_and_config | map run_plugin
}

get_sources()
{
	find $1 -name *.c*
}

all_sources()
{
	get_sources src
	get_sources test
}

validate_recipe()
{
	all_sources > /dev/null
	run_plugins is_validation
}

is_shared()
{
	jq -r .packaging $RECIPE | grep -q shared
}

is_archive()
{
	jq -r .packaging $RECIPE | grep -q archive
}

output_name()
{
	if is_shared; then
		echo lib$1.so
	elif is_archive; then
		echo lib$1.a
	else
		echo $1
	fi
}

get_name()
{
	jq -r .name $RECIPE | map output_name | echo build/$(cat)
}

object_file()
{
	echo build/$1.o
}

get_output()
{
	echo $1 | tr '.' ' ' | map object_file
}

library_packages()
{
	echo --libs
}

static_library_packages()
{
	echo --static --libs
}

include_packages()
{
	echo --cflags-only-I 
}

configure_package()
{
	echo $(pkg-config $($1) $2)
}

get_package()
{
	jq -r .package | map configure_package $1
}

get_packages()
{
	jq -c .dependencies $RECIPE | not is_null | jq -c .[]
}

is_test_dependency()
{
	echo $@ | jq .scope | grep -q test
}

is_static_dependency()
{
	echo $@ | jq .scope | grep -q static
}

source_dependencies()
{
	not is_test_dependency
}

base_directory()
{
	echo $1
}

get_includes()
{
	echo $(get_packages | $1 | get_package include_packages)
}

make_directory()
{
	mkdir -p build/$(dirname $1)
}

compile()
{
	make_directory $4
	verbose $COMPILER -c $($1) -o $(get_output $4) $($2) $(get_includes $3) $4

	if [ $? -eq 0 ]; then
		generate_hash $4 >> build/hashes
	fi
}

compilation_flag()
{
	if is_shared; then
		echo -fPIC
	fi
}

new_hash()
{
	echo $1 | grep '<'
}

source_file()
{
	echo $2
}

within_test()
{
	shift
	echo $@
}

try_in_source()
{
	if [ -f "$1" ]; then
		echo $1
	else
		echo src/$(echo $1 | tr '/' ' ' | map within_test | tr ' ' '/')
	fi 
}

header_file()
{
	echo $(dirname $1)/$2
}

match_include()
{
	local regex="#\s*include\s+\"(.+)\""

	if [[ $@ =~ $regex ]]; then
		echo ${BASH_REMATCH[1]}
	fi
}

with_headers()
{
	cat $1 | map match_include | map header_file $1 | map try_in_source
	echo $1
}

read_file()
{
	echo $(cat $1 2> /dev/null)
}

generate_hash()
{
	echo $1 | map with_headers | map read_file | echo $1 $(cat | openssl dgst)
}

get_missing_sources()
{
	get_sources $1 | map generate_hash | sort | diff -N -b - <(sort build/hashes) | filter new_hash | map source_file
}

has_object()
{
	[ -f $(get_output $1) ]
}

filter_old_hashes()
{
	cat build/hashes 2> /dev/null | filter has_object > build/oldhashes
	mv build/oldhashes build/hashes
}

compile_source()
{
	filter_old_hashes
	get_missing_sources src | parmap compile compilation_flag blank source_dependencies
}

compile_recipe()
{
	validate_recipe
	mkdir -p build/src
	compile_source
}

include_source()
{
	echo -Isrc
}

compile_tests()
{
	get_missing_sources test | parmap compile blank include_source all
}

without_flags()
{
	echo $1
}

is_valid_flag()
{
	echo "int main(void) {return 0;}" | $(without_flags $COMPILER) -x c -E - $1
}

filter_valid_flags()
{
	tr ' ' '\n' | filter is_valid_flag
}

get_links()
{
	echo $(get_packages | not is_static_dependency | $1 | get_package library_packages | filter_valid_flags)
}

get_static_links()
{
	echo $(get_packages | filter is_static_dependency | $1 | get_package static_library_packages | filter_valid_flags)
}

link_statically()
{
	echo -Wl,-Bstatic
	echo $@
}

output_flag()
{
	echo $1

	if is_shared; then
		echo -shared
	fi
}

link()
{
	verbose $(echo $COMPILER | map $1) -o $4 $5 $($2) $(get_links $3) $(get_static_links $3 | non_empty | map link_statically)
}

executable_file()
{
	echo $1
}

get_executable()
{
	echo $1 | tr '.' ' ' | map executable_file
}

get_executable_and_object()
{
	echo $(get_executable $1) $1
}

is_executable()
{
	objdump -d $1 | grep -q "<main>"
}

get_test_objects()
{
	all_sources | map get_output | not is_executable
}

link_tests()
{
	get_sources test | map get_output | filter is_executable | map get_executable_and_object | map link without_flags get_test_objects all
}

run()
{
	verbose $1
}

run_tests()
{
	get_sources test | map get_output | filter is_executable | map get_executable | map run
}

test_recipe()
{
	compile_recipe
	mkdir -p build/test
	compile_tests
	link_tests
	run_tests
}

get_source_objects()
{
	get_sources src | map get_output
}

archive()
{
	verbose ar rcs $(get_name) $(get_source_objects)
}

package_recipe()
{
	test_recipe
	if is_archive; then
		archive
	else
		link output_flag get_source_objects source_dependencies $(get_name) ''
	fi
}

is_verification()
{
	echo $@ | jq .phase | grep -q verify
}

verify_recipe()
{
	package_recipe
	if is_shared || is_archive; then
		echo "Library $(get_name) is not executable."
		exit 0
	else
		run_plugins is_verification
	fi
}

run_recipe()
{
	verify_recipe
	verbose $(get_name)
}

print_usage()
{
	echo "usage: cheesemake [clean] [<phase>]

Cheesemake runs ALL phases in order up to the one specified.

Phases:
 validate		Run plugins such as static analysis tools.
 compile		Compile sources in the src directory and output them to build/src.
 test			Compile and run tests in the test directory.
 package		Create a binary called build/<recipe name>.
 verify			Run plugins such as dynamic analysis tools.
 run			Run build/<recipe name>."
}

do_task()
{
	case $1 in
		clean) clean;;
		validate) validate_recipe;;
		compile) compile_recipe;;
		test) test_recipe;;
		package) package_recipe;;
		verify) verify_recipe;;
		run) run_recipe;;
		*) print_usage;;
	esac
}

for task in $@; do
	do_task $task
done

if [ $# -eq 0 ]; then
	print_usage
fi
