#! /usr/bin/env bash

set -Eeu

RECIPE=recipe.json

DIR=$(dirname $(readlink -f $0))

COMPILER=$(jq -r .compiler $RECIPE)

export LD_LIBRARY_PATH=build/lib

map()
{
	while read line; do
		$@ $line
	done
}

parmap()
{
	local pids=()

	while read line; do
		$@ $line &
		pids+=($!)
	done

	for pid in ${pids[@]}; do
		wait $pid
	done
}

filter()
{
	while read line; do
		if $@ $line &> /dev/null; then
			echo $line
		fi
	done
}

not()
{
	while read line; do
		if ! $@ $line &> /dev/null; then
			echo $line
		fi
	done
}

verbose()
{
	echo $@
	$@
}

all()
{
	echo $(cat)
}

blank()
{
	echo ''
}

non_empty()
{
	sed '/^$/d'
}

is_null()
{
	echo $1 | grep -q null
}

get_modules()
{
	jq -c .modules $RECIPE | not is_null | jq -r .[]
}

clean_module()
{
	(cd $1; clean)
}

clean()
{
	get_modules | map clean_module
	rm -rf build
}

object_file()
{
	echo build/$1.o
}

get_output()
{
	echo $1 | tr '.' ' ' | map object_file
}

has_object()
{
	test -f $(get_output $1)
}

has_module()
{
	test -d $1 && test -f $(cd $1; get_name)
}

has_object_or_module()
{
	has_object $1 || has_module $1
}

filter_old_hashes()
{
	cat build/hashes 2> /dev/null | filter has_object_or_module > build/oldhashes
	mv build/oldhashes build/hashes
}

hash_submodule()
{
	cat $1/build/hashes | echo $1 $(cat | openssl dgst) | map format_hash
}

get_sources()
{
	find $1 -name *.c*
}

all_sources()
{
	get_sources src
	get_sources test
}

match_include()
{
	local regex="#\s*include\s+\"(.+)\""

	if [[ $@ =~ $regex ]]; then
		echo ${BASH_REMATCH[1]}
	fi
}

header_file()
{
	echo $(dirname $1)/$2
}

shift_directory()
{
	shift
	echo $@
}

within_directory()
{
	echo $1 | tr -d ' ' | tr '/' ' ' | map shift_directory | tr ' ' '/'
}

try_in_source()
{
	if [ -f "$1" ]; then
		echo $1
	else
		echo src/$(echo $1 | map within_directory)
	fi
}

with_headers()
{
	cat $1 | map match_include | map header_file $1 | map try_in_source
	echo $1
}

read_file()
{
	echo $(cat $1 2> /dev/null)
}

format_hash()
{
	echo $1 $3
}

generate_hash()
{
	echo $1 | map with_headers | map read_file | echo $1 $(cat | openssl dgst) | map format_hash
}

module_sources()
{
	get_modules | map hash_submodule
	all_sources | map generate_hash
}

hash_module()
{
	(cd $1; module_sources | echo $1 $(cat | openssl dgst) | map format_hash)
}

new_hash()
{
	echo $1 | grep '<'
}

hash_name()
{
	echo $2
}

get_missing_modules()
{
	get_modules | map hash_module | sort | diff -N -b - <(sort build/hashes 2> /dev/null) | filter new_hash | map hash_name
}

remove_hash()
{
	cat build/hashes | grep -v $1 > build/oldhashes || true
	mv build/oldhashes build/hashes || true
	echo $1
}

copy_binaries_in()
{
	cp -r build/lib $1/build
	cp -r build/bin $1/build
	cp -r build/include $1/build
}

copy_binaries_out()
{
	cp -r $1/build/lib build
	cp -r $1/build/bin build
	cp -r $1/build/include build
}

verify_module()
{
	copy_binaries_in $1 || true
	(cd $1; verify_recipe)
	copy_binaries_out $1 || true
	hash_submodule $1 >> build/hashes
}

verify_modules()
{
	all_sources > /dev/null
	mkdir -p build/bin
	mkdir -p build/lib
	mkdir -p build/include
	filter_old_hashes
	get_missing_modules | map remove_hash | map verify_module
}

get_plugin_and_config()
{
	echo $(echo $@ | jq -r .name) $(echo $@ | jq -c .config)
}

run_plugin()
{
	source $DIR/$1.chevre $2
}

run_plugins()
{
    jq -c .plugins $RECIPE | not is_null | jq -c .[] | filter $1 | map get_plugin_and_config | map run_plugin
}

is_validation()
{
	echo $@ | jq .phase | grep -q validate
}

validate_recipe()
{
	verify_modules
	run_plugins is_validation
}

is_shared()
{
	jq -r .packaging $RECIPE | grep -q shared
}

is_archive()
{
	jq -r .packaging $RECIPE | grep -q archive
}

output_name()
{
	if is_shared; then
		echo lib/lib$1.so
	elif is_archive; then
		echo lib/lib$1.a
	else
		echo bin/$1
	fi
}

get_name()
{
	jq -r .name $RECIPE | map output_name | echo build/$(cat)
}

get_packages()
{
	jq -c .dependencies $RECIPE | not is_null | jq -c .[]
}

is_static_dependency()
{
	echo $@ | jq .scope | grep -q static
}

is_module_dependency()
{
	echo $@ | jq .scope | grep -q module
}

configure_package()
{
	pkg-config $($1) $2
}

get_package()
{
	jq -r .package | map configure_package $1
}

include_packages()
{
	echo --cflags-only-I 
}

get_includes()
{
	get_packages | not is_module_dependency | $1 | get_package include_packages
}

compile()
{
	verbose $COMPILER -c $($1) -o $(get_output $4) $($2) -Ibuild/include $(get_includes $3) $4

	if [ $? -eq 0 ]; then
		generate_hash $4 >> build/hashes
	fi
}

get_missing_sources()
{
	get_sources $1 | map generate_hash | sort | diff -N -b - <(sort build/hashes) | filter new_hash | map hash_name
}

make_directory()
{
	mkdir -p build/$(dirname $1)
	echo $1
}

compilation_flag()
{
	if is_shared; then
		echo -fPIC
	fi
}

is_test_dependency()
{
	echo $@ | jq .scope | grep -q test
}

source_dependencies()
{
	not is_test_dependency
}

compile_source()
{
	get_missing_sources src | map remove_hash | map make_directory | parmap compile compilation_flag blank source_dependencies
}

compile_recipe()
{
	validate_recipe
	mkdir -p build/src
	compile_source
}

include_source()
{
	echo -Isrc
}

compile_tests()
{
	get_missing_sources test | map remove_hash | map make_directory | parmap compile blank include_source all
}

library_packages()
{
	echo --libs
}

without_flags()
{
	echo $1
}

is_valid_flag()
{
	echo "int main(void) {return 0;}" | $(without_flags $COMPILER) -x c -E - $1
}

filter_valid_flags()
{
	tr ' ' '\n' | filter is_valid_flag
}

get_links()
{
	get_packages | not is_static_dependency | not is_module_dependency | $1 | get_package library_packages | filter_valid_flags
}

static_library_packages()
{
	echo --static --libs
}

get_static_links()
{
	get_packages | filter is_static_dependency | not is_module_dependency | $1 | get_package static_library_packages | filter_valid_flags
}

get_link()
{
	echo -l$1
}

get_module_links()
{
	get_packages | filter is_module_dependency | $1 | jq -r .package | map get_link
}

link_statically()
{
	echo -Wl,-Bstatic
	echo $@
}

link()
{
	verbose $(echo $COMPILER | map $1) -o $4 $5 $($2) -Lbuild/lib $(get_module_links $3) $(get_links $3) $(get_static_links $3 | non_empty | map link_statically)
}

is_executable()
{
	objdump -d $1 | grep -q "<main>"
}

executable_file()
{
	echo $1
}

get_executable()
{
	echo $1 | tr '.' ' ' | map executable_file
}

get_executable_and_object()
{
	echo $(get_executable $1) $1
}

get_test_objects()
{
	all_sources | map get_output | not is_executable
}

link_tests()
{
	get_sources test | map get_output | filter is_executable | map get_executable_and_object | parmap link without_flags get_test_objects all
}

run()
{
	verbose $1
}

run_tests()
{
	get_sources test | map get_output | filter is_executable | map get_executable | map run
}

test_recipe()
{
	compile_recipe
	mkdir -p build/test
	compile_tests
	link_tests
	run_tests
}

archive()
{
	verbose ar rcs $(get_name) $(get_source_objects)
}

output_flag()
{
	echo $1

	if is_shared; then
		echo -shared
	fi
}

get_source_objects()
{
	get_sources src | map get_output
}

make_include_directory()
{
	mkdir -p build/include/$(dirname $1)
	echo $1
}

copy_header()
{
	cp src/$1 build/include/$1
}

copy_headers()
{
	find src -name *.h* | map within_directory | map make_include_directory | map copy_header
}

package_recipe()
{
	test_recipe
	if is_archive; then
		archive
	else
		link output_flag get_source_objects source_dependencies $(get_name) ''
	fi
	copy_headers
}

is_verification()
{
	echo $@ | jq .phase | grep -q verify
}

verify_recipe()
{
	package_recipe
	if is_shared || is_archive; then
		echo "Library $(get_name) is not executable."
		exit 0
	else
		run_plugins is_verification
	fi
}

get_arguments()
{
	jq -r .args $RECIPE | not is_null
}

run_recipe()
{
	verify_recipe
	verbose $(get_name) $(get_arguments)
}

print_usage()
{
	echo "usage: cheesemake [clean] [<phase>]

Cheesemake runs ALL phases in order up to the one specified.

Phases:
 validate		Run plugins such as static analysis tools.
 compile		Compile sources in the src directory and output them to build/src.
 test			Compile and run tests in the test directory.
 package		Create a binary called build/<recipe name>.
 verify			Run plugins such as dynamic analysis tools.
 run			Run build/<recipe name>."
}

do_task()
{
	case $1 in
		clean) clean;;
		validate) validate_recipe;;
		compile) compile_recipe;;
		test) test_recipe;;
		package) package_recipe;;
		verify) verify_recipe;;
		run) run_recipe;;
		*) print_usage;;
	esac
}

for task in $@; do
	do_task $task
done

if [ $# -eq 0 ]; then
	print_usage
fi
