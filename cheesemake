#! /bin/bash

set -Eeu

RECIPE=recipe.json

DIR=$(dirname $(readlink -e $0))

COMPILER=$(jq -r .compiler $RECIPE)

map()
{
	while read line; do
		$@ $line
	done
}

parmap()
{
	local pids=()

	while read line; do
		$@ $line &
		pids+=($!)
	done

	for pid in ${pids[@]}; do
		wait $pid
	done
}

filter()
{
	while read line; do
		if $($@ $line &> /dev/null); then
			echo $line
		fi
	done
}

not()
{
	while read line; do
		if ! $($@ $line &> /dev/null); then
			echo $line
		fi
	done
}

verbose()
{
	echo $@
	$@
}

all()
{
	echo $(cat)
}

blank()
{
	echo ''
}

non_empty()
{
	sed '/^$/d'
}

clean()
{
	rm -rf build
}

is_null()
{
	echo $1 | grep null
}

get_plugin_and_config()
{
	echo $(echo $@ | jq -r .name) $(echo $@ | jq -c .config)
}

is_validation()
{
	echo $@ | jq .phase | grep validate
}

run_plugin()
{
	source $DIR/$1.chevre $2
}

run_plugins()
{
    jq -c .plugins $RECIPE | not is_null | jq -c .[] | filter $1 | map get_plugin_and_config | map run_plugin
}

validate_recipe()
{
	run_plugins is_validation
}

get_sources()
{
	find $1 -name *.c*
}

is_shared()
{
	jq -r .packaging $RECIPE | grep shared
}

is_archive()
{
	jq -r .packaging $RECIPE | grep archive
}

output_name()
{
	if is_shared &> /dev/null; then
		echo lib$1.so
	elif is_archive &> /dev/null; then
		echo lib$1.a
	else
		echo $1
	fi
}

get_name()
{
	jq -r .name $RECIPE | map output_name | echo build/$(cat)
}

make_directory()
{
	mkdir -p build/$(dirname $1)
}

object_file()
{
	echo build/$1.o
}

get_output()
{
	echo $1 | tr '.' ' ' | map object_file
}

library_packages()
{
	echo --libs
}

static_library_packages()
{
	echo --static --libs
}

include_packages()
{
	echo --cflags-only-I 
}

configure_package()
{
	echo $(pkg-config $($1) $2)
}

get_package()
{
	jq -r .package | map configure_package $1
}

get_packages()
{
	jq -c .dependencies $RECIPE | not is_null | jq -c .[]
}

is_test_dependency()
{
	echo $@ | jq .scope | grep test
}

is_static_dependency()
{
	echo $@ | jq .scope | grep static
}

source_dependencies()
{
	not is_test_dependency
}

get_includes()
{
	echo $(get_packages | $1 | get_package include_packages)
}

compilation_flag()
{
	if is_shared $> /dev/null; then
		echo -fPIC
	fi
}

compile()
{
	make_directory $4
	verbose $COMPILER -c $($1) -o $(get_output $4) $($2) $(get_includes $3) $4
}

has_object()
{
	[ -f $(get_output $2) ]
}

new_hash()
{
	echo $1 | grep '<'
}

source_file()
{
	echo $3
}

filter_old_hashes()
{
	cat build/$1/hashes 2> /dev/null | filter has_object > build/$1/oldhashes
}

get_missing_sources()
{
	get_sources $1 | map sha1sum | tee build/$1/hashes | diff -N -b - build/$1/oldhashes | filter new_hash | map source_file
}

compile_source()
{
	filter_old_hashes src
	get_missing_sources src | parmap compile compilation_flag blank source_dependencies
	rm build/src/oldhashes
}

compile_recipe()
{
	validate_recipe
	mkdir -p build/src
	compile_source
}

include_source()
{
	echo -Isrc
}

compile_tests()
{
	filter_old_hashes test
	get_missing_sources test | parmap compile blank include_source all
	rm build/test/oldhashes
}

without_flags()
{
	echo $1
}

is_valid_flag()
{
	echo "int main(void) {return 0;}" | $(echo $COMPILER | map without_flags) -x c -E - $1
}

filter_valid_flags()
{
	tr ' ' '\n' | filter is_valid_flag
}

get_links()
{
	echo $(get_packages | not is_static_dependency | $1 | get_package library_packages | filter_valid_flags)
}

get_static_links()
{
	echo $(get_packages | filter is_static_dependency | $1 | get_package static_library_packages | filter_valid_flags)
}

link_statically()
{
	echo -Wl,-Bstatic
	echo $@
}

output_flag()
{
	echo $1

	if is_shared $> /dev/null; then
		echo -shared
	fi
}

link()
{
	verbose $(echo $COMPILER | map $1) -o $4 $5 $($2) $(get_links $3) $(get_static_links $3 | non_empty | map link_statically)
}

all_sources()
{
	get_sources src
	get_sources test
}

executable_file()
{
	echo $1
}

get_executable()
{
	echo $1 | tr '.' ' ' | map executable_file
}

get_executable_and_object()
{
	echo $(get_executable $1) $1
}

is_executable()
{
	objdump -d $1 | grep -m 1 "<main>"
}

get_test_objects()
{
	all_sources | map get_output | not is_executable
}

link_tests()
{
	get_sources test | map get_output | filter is_executable | map get_executable_and_object | map link without_flags get_test_objects all
}

run()
{
	verbose $1
}

run_tests()
{
	get_sources test | map get_output | filter is_executable | map get_executable | map run
}

test_recipe()
{
	compile_recipe
	mkdir -p build/test
	compile_tests
	link_tests
	run_tests
}

get_source_objects()
{
	get_sources src | map get_output
}

archive()
{
	verbose ar rcs $(get_name) $(get_source_objects)
}

package_recipe()
{
	test_recipe
	if is_archive &> /dev/null; then
		archive
	else
		link output_flag get_source_objects source_dependencies $(get_name) ''
	fi
}

is_verification()
{
	echo $@ | jq .phase | grep verify
}

verify_recipe()
{
	package_recipe
    run_plugins is_verification
}

run_recipe()
{
	verify_recipe
	get_name | map run
}

print_usage()
{
	echo "usage: cheesemake [clean] [<phase>]

Cheesemake runs ALL phases in order up to the one specified.

Phases:
 validate		Run plugins such as static analysis tools.
 compile		Compile sources in the src directory and output them to build/src.
 test			Compile and run tests in the test directory.
 package		Create an executable called build/<recipe name>.
 verify			Run plugins such as dynamic analysis tools.
 run			Run build/<recipe name>."
}

do_task()
{
	case $1 in
		clean) clean;;
		validate) validate_recipe;;
		compile) compile_recipe;;
		test) test_recipe;;
		package) package_recipe;;
		verify) verify_recipe;;
		run) run_recipe;;
		*) print_usage;;
	esac
}

for task in $@; do
	do_task $task
done

if [ $# -eq 0 ]; then
	print_usage
fi
